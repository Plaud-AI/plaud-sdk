#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
#ifndef PENBLESDK_SWIFT_H
#define PENBLESDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreFoundation;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PenBleSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class BleDevice;
@protocol BleAgentProtocol;
@protocol GlassProtocol;
@class NSString;
@class NSData;
@class UpdateInfo;
/// Bluetooth transmission control class
SWIFT_CLASS("_TtC9PenBleSDK8BleAgent")
@interface BleAgent : NSObject
/// Singleton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) BleAgent * _Nonnull shared;)
+ (BleAgent * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Wrapped recording pen entity class
@property (nonatomic, strong) BleDevice * _Nullable bleDevice;
@property (nonatomic, weak) id <BleAgentProtocol> _Nullable delegate;
@property (nonatomic, weak) id <GlassProtocol> _Nullable glassDelegate;
/// Whether Bluetooth is available
@property (nonatomic, readonly) BOOL isPoweredOn;
/// Whether device is connected
@property (nonatomic, readonly) BOOL isConnected;
/// Whether device is bound
@property (nonatomic, readonly) BOOL isBinded;
/// Whether sync file list only gets single file
@property (nonatomic, readonly) BOOL isOnlyOne;
/// iselsecurrentinRecording
@property (nonatomic, readonly) BOOL isRecording;
@property (nonatomic, readonly) BOOL needDecode;
@property (nonatomic, readonly) BOOL isMusic;
/// Current recording scene
@property (nonatomic, readonly) NSInteger scene;
@property (nonatomic, readonly) NSInteger settingScene;
/// Current recording file or sync (download) file sessionId
@property (nonatomic, readonly) NSInteger sessionId;
/// Whether syncing (downloading) file
@property (nonatomic, readonly) BOOL isDownloading;
/// Whether Bluetooth disconnection is caused by WiFi switching
@property (nonatomic, readonly) BOOL isWiFiOpen;
/// Duplicate command interval, default 500ms
/// Three commands getFileList, syncFile, deleteFile are specially handled, adding sessionId and start to determine if it’s a duplicate command
@property (nonatomic) NSInteger repeatCommondInterval;
/// Command callback thread, default is main thread
@property (nonatomic, strong) dispatch_queue_t _Nonnull cmdDelegateQueue;
/// Is it in U disk mode?
@property (nonatomic) BOOL isUsbState;
@property (nonatomic) BOOL isCharging;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Is WiFi transmission open? Those without WiFi module don’t need to care
/// \param connected Whether connected
///
- (void)setWiFiState:(BOOL)connected;
/// User authentication initialization (must be called)
/// \param appKey Key bound to package name
///
/// \param bindToken Used to bind recording pen, should be account unique, recommend using openid from server
///
/// \param hkServer Whether to use HK server
/// @see Callback see bleAppKeyState、
///
- (void)setUserIdentifier:(NSString * _Nonnull)appKey :(NSString * _Nonnull)bindToken :(BOOL)hkServer;
/// Initialize Bluetooth, call before using Bluetooth related interfaces (must be called)
- (void)initBluetooth SWIFT_METHOD_FAMILY(none);
/// Will disconnect first then set centralManager to nil
- (void)disInitBluetooth;
/// Verify AppKey, first verification requires network
/// This method is recommended to be called in AppDelegate, subsequent functions can only be used after successful verification
/// \param appKey Key bound to package name
/// @see        bleAppKeyState
/// @deprecated     This method is deprecated, replaced by setUserIdentifier() method
///
- (void)checkAppKey:(NSString * _Nonnull)appKey;
/// Set token for binding recording pen
/// Token should be account unique and won’t expire, best generated uniformly by server
/// \param token 
/// @deprecated     This method is deprecated, replaced by setUserIdentifier() method
///
- (void)setBinding:(NSString * _Nonnull)token;
/// Set filter name when scanning
/// This method only filters one Bluetooth name after setting
/// If set to nil, will display all recording pens conforming to protocol
/// \param name Bluetooth name
/// @see    setFilter(_ names: [String])
///
- (void)setFilterWithName:(NSString * _Nullable)name;
/// Filter multiple simultaneously
/// If array is empty, will display all recording pens conforming to protocol
/// \param names Bluetooth names
/// @see    setFilter(name: String)
///
- (void)setFilter:(NSArray<NSString *> * _Nonnull)names;
/// Open SDK debug log or callback log
- (void)openLog:(BOOL)opened :(void (^ _Nullable)(NSString * _Nonnull))backBlock;
/// Is connected to a device
/// Bluetooth on, connected, bound and bleDevice not nil
///
/// returns:
/// true or false
- (BOOL)isDeviceConnect SWIFT_WARN_UNUSED_RESULT;
/// Start scanning
/// @see        startLoopScan()
/// @see        stopScan()
/// @see        Callback bleScanResult
- (void)startScan;
/// Start a loop scan
/// Internally starts a timer, scans every 12 seconds until connected to recording pen; restarts timer after disconnection
/// App should connect bound devices in scan callback
/// @see        startScan()
/// @see        stopScan()
/// @see        Callback bleScanResult
/// @deprecated     This method is deprecated, not recommended for use
- (void)startLoopScan;
/// End scanning
/// @see        startLoopScan()
/// @see        startScan()
- (void)stopScan;
/// Connect Bluetooth device
/// No longer supports auto connection, device version is obtained during scanning, auto connection cannot update version, will have issues after recording pen upgrade
/// @see startLoopScan
/// \param bleDevice Wrapped Bluetooth device
///
/// \param devToken Pen-side token from QR code binding, length is 8 after utf-8 conversion to data, non-QR code binding is 8 zeros (for Jetone, other customers should not pass)
///
/// \param userName Username (for Jetone, other customers should not pass)
/// @see    Callback bleConnectState
/// @see    Callback bleBind
///
- (void)connectBleDeviceWithBleDevice:(BleDevice * _Nonnull)bleDevice :(NSString * _Nullable)devToken :(NSString * _Nullable)userName;
/// Disconnect Bluetooth connection
- (void)disconnect;
/// Is the recording pen temporarily authenticated?
- (BOOL)isSNTempChecked SWIFT_WARN_UNUSED_RESULT;
/// If SN verification was not successful before, re-verify
- (void)reCheckSNIfNeed;
/// Actively read battery level
/// This reads the standard battery level service, may be inaccurate in some cases
/// Protocol 5 and later automatically changed to getChargingState
/// @see    getChargingState
/// @see    CallbackblePowerChange
/// @see    CallbackbleChargingState
- (void)readPower;
/// Get battery level state
/// Protocol 5 and later changed to use this method to read battery count, readPower will also use this in Protocol 5 and later
/// @see    CallbackblePowerChange
/// @see    CallbackbleChargingState
- (void)getChargingState;
/// Read recording pen state, return state and privacy state
/// @see    CallbackblePenState
- (void)getState;
/// Cancel pair, unbind
/// \param clear Whether to clear recording pen at the same time
///
- (void)depairWithClear:(BOOL)clear;
/// Read recording pen remaining space
/// @see    CallbackbleStorage
- (void)getStorage;
/// Reset pen device password, used for multi-key screen projects, e.g. Newman P23H
/// @see    CallbackblePasswordReset
- (void)appResetPassword;
/// Read backlight duration
/// Used for screen non-multi-key projects e.g. P23R1.
/// @see    setBacklightDuration
/// @see    CallbackbleBacklightDuration
- (void)readBacklightDuration;
/// Set backlight duration
/// Used for screen non-multi-key projects e.g. P23R1.
/// \param type Duration enumeration 0: 10 seconds 1: 20 seconds 2: 30 seconds 4: Always on
/// @see    readBacklightDuration
/// @see    CallbackbleBacklightDuration
///
- (void)setBacklightDurationWithType:(NSInteger)type;
/// Read backlight brightness
/// Used for screen non-multi-key projects e.g. P23R1.
/// @see    setBacklightBright
/// @see    CallbackbleBacklightBright
- (void)readBacklightBright;
/// Set backlight brightness
/// Used for screen non-multi-key projects e.g. P23R1.
/// \param type Brightness level enumeration 1-6
/// @see    readBacklightBright
/// @see    CallbackbleBacklightBright
///
- (void)setBacklightBrightWithType:(NSInteger)type;
/// SetupuptransferAddress
/// \param path uptransferAddress
///
- (void)setWifiSyncDomainWithDomain:(NSString * _Nonnull)domain;
- (void)getWifiSyncUrl;
/// Screen project get recording pen current language
/// @see    setLanguage
/// @see    CallbackbleLanguage
- (void)readLanguage;
/// Screen project set recording pen language
/// \param type Language type 0 Simplified Chinese 1 Traditional Chinese 2 English
/// @see    readLanguage
/// @see    CallbackbleLanguage
///
- (void)setLanguageWithType:(NSInteger)type;
/// Set recording scene
/// \param value 0 Unknown; 1 Normal; 2 Interview; 3 Classroom(Speech); 4 Music; 5 Meeting; 6 Memo
///
- (void)setRecSceneWithValue:(NSInteger)value;
/// Get recording scene
/// @see    CallbackbleRecScene
- (void)readRecScene;
/// Set recording mode
/// \param value 1 Normal (normal, non-noise reduction); 2 NC (noise reduction)
///
- (void)setRecModeWithValue:(NSInteger)value;
/// Get recording mode
/// @see    bleRecMode
- (void)readRecMode;
/// Set VAD sensitivity
/// \param value 0：Quality 1：Low bitrate  2：Normal 3：Aggressive
///
- (void)setVadSensitivityWithSensitivity:(NSInteger)sensitivity;
/// Get VAD sensitivity
/// @see    bleVadSensitivity
- (void)readVadSensitivity;
/// Set VPU sensitivity
/// \param sensitivity 0：Low 1：Medium 2：High
///
- (void)setVpuGainWithGain:(NSInteger)gain;
/// Get VPU sensitivity
/// @see    bleVpuGain
- (void)readVpuGain;
/// Set microphone gain
/// \param value Microphone gain value, range 0 - 30
///
- (void)setMicGainWithValue:(NSInteger)value;
/// Get microphone gain
/// @see    bleMicGain
- (void)readMicGain;
/// Set switch function
/// \param id 0 call scene switching; 1 recording function; 2 power off function
///
- (void)setSwitchHandlerWithId:(NSInteger)id;
/// Get switch function
/// @see    bleSwitchHandler
- (void)readSwitchHandler;
/// Set auto power off
/// \param value 0: Off 1: Immediate power off 2: 15 minutes 3: 30 minutes 4: 1 hour 5: 5 hours
///
- (void)setAutoPowerOffWithValue:(NSInteger)value;
/// Get auto power off setting
/// @see    bleAutoPowerOff
- (void)readAutoPowerOff;
/// Set whether to save raw wav files
/// \param value 0: Off 1: On
///
- (void)setRawWaveEnabledWithValue:(NSInteger)value;
/// Get raw wav file enabled status
/// @see    bleRawWaveEnabled
- (void)readRawWaveEnabled;
/// Get recording after charger disconnected enabled status
/// @see bleRecordingAfterDisConnetEnabled
- (void)readRecordingAfterDisConnetEnabled;
/// Set recording after charger disconnected enabled
/// \param value 0: Off 1: On
///
- (void)setRecordingAfterDisConnetEnabledWithValue:(NSInteger)value;
/// Get idle time sync enabled status
/// @see bleSyncWhenIdleEnabled
- (void)readSyncWhenIdleEnabled;
/// Set idle time sync enabled
/// \param value 0: Off 1: On
///
- (void)setSyncWhenIdleEnabledWithValue:(NSInteger)value;
/// Set device FindMy state
/// \param value 
/// 0: Unbound state - Close advertising
/// 1: Unbound state - Open advertising
/// 2: Bound state - Can be found
/// 3: Bound state - Cannot be found
///
- (void)setFindMyStateWithValue:(NSInteger)value;
/// Get device FindMy state
/// @see    bleFindMyState
- (void)readFindMyState;
/// Set VPU CLK correction
/// \param value 0: Off 1: On
/// @see    Callback bleSetVpuCLK
///
- (void)setVPUCLKWithValue:(NSInteger)value;
/// Read VPU CLK correction
/// @see    Callback bleVpuCLK
- (void)readVPUCLK;
/// Set auto stop recording after charger insertion
/// \param value 0: Off 1: On
/// @see    Callback bleStopRecordingAfterCharging
///
- (void)setStopRecordingAfterChargingWithValue:(NSInteger)value;
/// Read auto stop recording after charger insertion
/// @see    Callback bleStopRecordingAfterCharging
- (void)readStopRecordingAfterCharging;
/// Set BLE name
/// \param name Device new name
///
- (void)setBleNameWithName:(NSString * _Nonnull)name;
/// Get BLE name
/// @see    bleName
- (void)readBleName;
/// App request open or close WiFi
/// \param open Open or close
///
- (void)operateWiFiWithOpen:(BOOL)open;
/// Get recording report
/// \param uid Distinguish consecutive requests
///
- (void)readGlassDataWithUid:(NSInteger)uid;
/// Clear recording report
- (void)clearGlassData;
/// Get pen device auto delete recording state value
/// @see    saveAutoClear
/// @see    CallbackbleAutoClear
- (void)readAutoClear;
/// Save auto clear recording state
/// Note: Recording pen only saves the state, convenient for account sync setting state, whether to delete pen device recording after sync completion is still controlled by app
/// \param status 0 Close 1 Open
/// @see    readAutoClear
/// @see    CallbackbleAutoClear
///
- (void)saveAutoClear:(BOOL)open;
/// Start recording
/// If start recording succeeds, need to call syncFile to sync files yourself
/// Can display real-time recording duration through sync file offset
/// \param scene Recording scene 1: Meeting 2: Classroom 3: Interview 4: Music 5: Memo
/// @see    CallbackbleRecordStart
///
- (void)startRecord:(NSInteger)scene;
/// Stop current recording
/// @see    CallbackbleRecordStop
- (void)stopRecord;
/// Pause recording
/// If current recording is in pause state, before version 7 use @see startRecord() to resume recording, after version 7 use resumeRecord() to resume
/// Recording pen protocol 7 and later need to pass sessionId, early versions ignore it
/// @see    CallbackbleRecordPause
- (void)pauseRecord:(NSInteger)sessionId;
/// Resume recording
/// Supported from protocol version 7
/// @see CallbackbleRecordResume
- (void)resumeRecord:(NSInteger)sessionId;
/// Get recording pen LED state
/// @see    setLedState
/// @see    CallbackbleLedState
- (void)getLedState;
/// Set recording pen LED state
/// \param onOff 0 normal; 1 off
/// @see    getLedState
/// @see    CallbackbleSetLedState
///
- (void)setLedStateOnOff:(NSInteger)onOff;
/// Get session list (get file list after a certain sessionId)
/// This command cannot be used in recording state
/// This command cannot be used in USB mode
/// \param uid Used to distinguish different commands
///
/// \param sessionId From which file to start syncing? 0 means sync all
///
/// \param onlyOne If true, only query files for this sessionId (get real-time recording file length after real-time recording ends), default false
/// @see    CallbackbleFileList
///
- (void)getFileListWithUid:(NSInteger)uid sessionId:(NSInteger)sessionId onlyOne:(BOOL)onlyOne;
/// Sync (download) file
/// \param sessionId Unique ID of recording file
///
/// \param start Recording file start position (Byte)
///
/// \param end Sync to where? Generally pass 0, means sync to file end (Byte)
///
/// \param decode Whether to return decoded data at the same time
/// @see    CallbackbleSyncFileHead
/// @see    CallbackbleSyncFileTail
/// @see    CallbackbleData
/// @see    CallbackbleDecodeFail
/// @see    CallbackbleDataComplete
/// @see    CallbackblePcmData
///
- (void)syncFileWithSessionId:(NSInteger)sessionId start:(NSInteger)start end:(NSInteger)end decode:(BOOL)decode;
- (void)stopSyncFile;
/// Delete file in recording pen
/// \param sessionId Unique ID of recording file
/// @see    CallbackbleDeleteFile
///
- (void)deleteFileWithSessionId:(NSInteger)sessionId;
/// Get recording marking data
/// \param sessionId Sessionid
///
- (void)getMarking:(NSInteger)sessionId;
/// Notify recording pen of version upgrade
/// \param uid Command identifier
///
/// \param fromVersion Current version T0012 or V0012 format
///
/// \param toVersion Target version T0012 or V0012 format
///
/// \param thirdVersion G101 project, others fill 0
///
/// \param fileSize Upgrade package size (bytes)
///
/// \param crc Checksum
/// @see    CallbackbleFotaResult
/// @see    CallbackbleFotaPackReq
///
- (void)pushFotaInfo:(NSInteger)uid :(NSString * _Nonnull)fromVersion :(NSString * _Nonnull)toVersion :(NSInteger)thirdVersion :(NSInteger)fileSize :(NSInteger)crc;
/// Notify recording pen of version upgrade
/// Target version must be greater than original version
/// \param uid Command identifier
///
/// \param fromVersion Original version
///
/// \param fromVersionType Original version type
///
/// \param toVersion Target version
///
/// \param toVersionType Target version type
///
/// \param fileSize Upgrade package size (bytes)
///
/// \param crc Checksum
/// @see    CallbackbleFotaResult
/// @see    CallbackbleFotaPackReq
///
- (void)pushFotaInfo:(NSInteger)uid :(NSInteger)fromVersion :(NSString * _Nonnull)fromVersionType :(NSInteger)toVersion :(NSString * _Nonnull)toVersionType :(NSInteger)thirdVersion :(NSInteger)fileSize :(NSInteger)crc;
/// Tell recording pen file has been sent completely
/// \param uid Identifier, distinguish commands
///
/// \param status 0 normal end, 1 user exit, 0XFF unknown reason
///
- (void)pushFotaComplete:(NSInteger)uid :(NSInteger)status;
/// Send OTA data package
/// Don’t send all packages in one loop, each package needs to wait for a time interval
/// Different phones have different Bluetooth versions, waiting time is different, this needs actual testing
/// Currently iPhone 6 waits
/// \param offset Offset (bytes)
///
/// \param packData Data package, note to control single data package size, don’t exceed max length (different models have different values, conservatively use 80)
///
- (void)pushFotaPack:(NSInteger)offset packData:(NSData * _Nonnull)packData;
/// Can we push data to unstable stack?
- (BOOL)canSendWithoutResponse SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=11.0);
/// Restore factory settings
/// No callback
- (void)restoreFactory;
/// Privacy setting
/// When enabled, disable pen device playback, disable U disk function, disable pen device unbind
/// \param onOff 1 enable; 0 disable
/// @see    getState
/// @see    CallbackblePrivacy
///
- (void)setPrivacyOnOff:(NSInteger)onOff;
/// Clear all files from pen device
/// @see    CallbackbleClearAllFile
- (void)clearAllFile;
/// Device sleep and wake up
/// \param onOff 1 wake up; 0 sleep
///
- (void)setDeviceActiveWithStatus:(NSInteger)status;
/// WiFi network configuration
/// \param ssid WiFi name
///
/// \param password Password
///
/// \param isTest Whether to use test environment
///
- (void)setWiFiSsidWithSsid:(NSString * _Nonnull)ssid password:(NSString * _Nonnull)password isTest:(BOOL)isTest;
/// App request current network configuration state from device
- (void)getWiFiSsid;
/// Get firmware update info
/// \param callback errcode == 0 indicates HTTP success return
///
- (void)getUpdateInfo:(void (^ _Nonnull)(NSInteger, UpdateInfo * _Nullable))callback;
/// Set server configuration
/// \param type 1 server url 2 server token 2 device token
///
/// \param content url max 63 bytes; serToken max 16 bytes; devToken max 16 bytes
///
- (void)setWebsocketProfileWithType:(NSInteger)type content:(NSString * _Nonnull)content;
/// Get server configuration
- (void)getWebsocketProfileWithType:(NSInteger)type;
/// Server test
- (void)testWebsocket;
/// Set scheduled recording
/// \param start Scheduled alarm start time interval (UTC); 0 means close scheduled alarm
///
/// \param duration Duration (in seconds)
///
/// \param repeatMode 0 once only; 1 daily scheduled; 2 weekly scheduled
///
- (void)setAlarmRecWithStart:(NSInteger)start duration:(NSInteger)duration repeatMode:(NSInteger)repeatMode;
/// Get scheduled recording
- (void)getAlarmRec;
/// Send binary file info
/// \param type FileType
///
/// \param totalSize File total size
///
- (void)sendBinFileInfoWithType:(NSInteger)type totalSize:(NSInteger)totalSize;
/// Send binary file data
/// \param type FileType
///
/// \param packageOffset Package offset
///
/// \param packageSize packet size
///
/// \param data Package data
///
- (void)sendBinFileDataWithType:(NSInteger)type packageOffset:(NSInteger)packageOffset packageSize:(NSInteger)packageSize data:(NSData * _Nonnull)data;
/// Send binary file checksum result
/// \param type FileType
///
/// \param crc Checksum
///
- (void)sendBinFileCheckSumResultWithType:(NSInteger)type crc:(NSInteger)crc;
/// Get idle time sync Wi-Fi configuration
/// \param wifiIndex Wi-Fi index (4 bytes)
///
- (void)getSyncInIdleWifiConfigWithWifiIndex:(uint32_t)wifiIndex;
/// Set idle time sync Wi-Fi configuration
/// \param operation Operation type 1: add, 2: modify)
///
/// \param wifiIndex Wi-Fi index (4 bytes)
///
/// \param ssid Wi-Fi SSID
///
/// \param password Wi-Fi password
///
- (void)setSyncInIdleWifiConfigWithOperation:(NSInteger)operation wifiIndex:(uint32_t)wifiIndex ssid:(NSString * _Nonnull)ssid password:(NSString * _Nonnull)password;
/// Delete idle time sync Wi-Fi configuration
/// \param wifiIndices Array of Wi-Fi indices to delete (each index is 4 bytes)
///
- (void)deleteSyncInIdleWifiConfigWithWifiIndices:(NSArray<NSNumber *> * _Nonnull)wifiIndices;
/// Reset findmy state
- (void)resetFindmy;
/// Get idle time sync Wi-Fi list
- (void)getSyncInIdleWifiList;
/// Start idle time sync Wi-Fi test
/// \param wifiIndex Wi-Fi index (4 bytes)
///
- (void)setSyncInIdleWifiTestWithWifiIndex:(uint32_t)wifiIndex;
/// Get idle time sync Wi-Fi test result
/// \param wifiIndex Wi-Fi index (4 bytes)
///
- (void)getSyncInIdleWifiTestResultWithWifiIndex:(uint32_t)wifiIndex;
/// Set SoundPlus license key
/// \param licenseKey license key string (if converted to less than 64 bytes, will use 0 to fill up)
///
- (void)setSoundPlusTokenWithLicenseKey:(NSString * _Nonnull)licenseKey;
/// Get device SDFLASH CID
- (void)getSDFLASHCID;
@end

/// PCM streaming decoding protocol
SWIFT_PROTOCOL("_TtP9PenBleSDK20JXPcmProcessDelegate_")
@protocol JXPcmProcessDelegate
/// Callback PCM data
/// \param sessionId Recording ID
///
/// \param millSec Current data millisecond value (starting moment millisecond value)
///
/// \param pcmData Pure audio decoded data, length is 20ms
///
- (void)onPcmData:(NSInteger)sessionId :(NSInteger)millSec :(NSData * _Nonnull)pcmData;
- (void)onDecodeErr:(NSInteger)millSec;
@end

@interface BleAgent (SWIFT_EXTENSION(PenBleSDK)) <JXPcmProcessDelegate>
- (void)onPcmData:(NSInteger)sessionId :(NSInteger)millSec :(NSData * _Nonnull)pcmData;
- (void)onDecodeErr:(NSInteger)millSec;
@end

@class CBCentralManager;
@class CBPeripheral;
@class NSNumber;
@interface BleAgent (SWIFT_EXTENSION(PenBleSDK)) <CBCentralManagerDelegate>
/// Check mobile phone Bluetooth state
/// MARK - SDK implements system callback, app does not need to call
- (void)centralManagerDidUpdateState:(CBCentralManager * _Nonnull)central;
/// Scan peripheral device then connect
/// MARK - SDK implements system callback, app does not need to call
- (void)centralManager:(CBCentralManager * _Nonnull)central didDiscoverPeripheral:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI;
/// Connect Success
/// mark - SDK implements system callback, app does not need to call
- (void)centralManager:(CBCentralManager * _Nonnull)central didConnectPeripheral:(CBPeripheral * _Nonnull)peripheral;
/// Connect Failed
/// mark - SDK implements system callback, app does not need to call
- (void)centralManager:(CBCentralManager * _Nonnull)central didFailToConnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
/// Disconnect Connect, try to reconnect
/// mark - SDK implements system callback, app does not need to call
- (void)centralManager:(CBCentralManager * _Nonnull)central didDisconnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
@end

@class NSURLSession;
@class NSURLAuthenticationChallenge;
@class NSURLCredential;
@interface BleAgent (SWIFT_EXTENSION(PenBleSDK)) <NSURLSessionDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
@end

@interface BleAgent (SWIFT_EXTENSION(PenBleSDK))
/// AuthorizeiselseSuccess
- (BOOL)isAuthOk SWIFT_WARN_UNUSED_RESULT;
/// Convert dual channel to single channel
/// \param pcmData One data packet, size should be 1280
///
- (NSData * _Nonnull)toSingleChannel:(NSData * _Nonnull)pcmData SWIFT_WARN_UNUSED_RESULT;
@end

@class BleFile;
/// Delegate
SWIFT_PROTOCOL("_TtP9PenBleSDK16BleAgentProtocol_")
@protocol BleAgentProtocol
/// Insufficient power during upgrade
/// Check during pushFotaInfo (upgrade not allowed when power is below 40)
- (void)bleUpdatePowerLowErr;
/// Device not connected
/// Check if normally connected to device before sending commands
- (void)bleDeviceDisconnectErr;
/// When recording pen is in U disk mode, calling getFileList/startRecord/syncFile/deleteFile/pushFotaInfo methods will callback this exception
/// When recording pen connects for the first time, app needs to call getState to get recording pen status
/// \param funcName Method name not supported in U disk mode
///
- (void)bleUDiskErrWithFuncName:(NSString * _Nonnull)funcName;
/// appKey verification result
/// \param result Verification result 0 temporary 1 success 2 failure
///
- (void)bleAppKeyStateWithResult:(NSInteger)result;
/// Bluetooth status callback
/// \param powered Is it available?
///
- (void)bleStateWithPowered:(BOOL)powered;
/// Bluetooth connection status
/// <ul>
///   <li>
///     Parameters state: 0 disconnected or not connected; 1 connection successful; 2 connection failed
///   </li>
/// </ul>
- (void)bleConnectStateWithState:(NSInteger)state;
/// Scan Bluetooth device callback
/// \param bleDevices Bluetooth device list
///
- (void)bleScanResultWithBleDevices:(NSArray<BleDevice *> * _Nonnull)bleDevices;
/// Scan timeout ended
/// @see startScan
- (void)bleScanOverTime;
/// Waiting for user confirmation
/// \param timeout Timeout duration, unit seconds
///
- (void)bleHandshakeWaitWithTimeout:(NSInteger)timeout;
/// Connection callback
/// \param status Status, 0: success, >0: rejection 1: Token mismatch 2: Screen project, recording in progress, user temporarily unable to confirm 3: Screen project, user manually rejected 255: Recording pen not in connection mode, rejecting handshake request in non-connection mode (specific to Heili three-way switch) <0 verification failed -1: No SSN -2: Network exception -3: Server data exception or verification incorrect
///
/// \param protVersion Protocol version number
///
/// \param timezone Current timezone of pen side
///
- (void)bleBindWithSn:(NSString * _Nullable)sn status:(NSInteger)status protVersion:(NSInteger)protVersion timezone:(NSInteger)timezone;
/// Device name
/// \param name Device name
///
- (void)bleDeviceNameWithName:(NSString * _Nullable)name;
/// Battery level change
/// \param power Current battery level
///
/// \param oldPower Previous battery level (used to determine 20%->19% and 10%->9% low battery reminders)
///
- (void)blePowerChangeWithPower:(NSInteger)power oldPower:(NSInteger)oldPower;
/// Battery level status
/// \param isCharging Whether charger is inserted 0 not inserted 1 inserted (BleDevice has an isCharging property that is set after this callback, can compare previous value to determine charging status change)
///
/// \param level Battery level 0-100
///
- (void)bleChargingStateWithIsCharging:(BOOL)isCharging level:(NSInteger)level;
/// Return status
/// \param state Customized according to project (4099(0x00001003) means recording pen is recording, 1 seems to be recording)
///
/// \param privacy Privacy setting status
///
/// \param keySatte Toggle switch status (added in protocol version 4)
///
/// \param uDisk Whether U disk is enabled
/// Other two parameters are directly placed in BleAgent
///
/// \param scene Current recording scene (0 when not recording)
///
/// \param findMyToken Whether findmy token exists (NotePin device)
///
/// \param hasSndpKey Whether SoundPlus license token exists
///
/// \param deviceAccessToken Whether device idle sync AccessToken exists
///
/// \param sessionId Current session id (0 when not recording)
///
- (void)blePenStateWithState:(NSInteger)state privacy:(NSInteger)privacy keyState:(NSInteger)keyState uDisk:(NSInteger)uDisk findMyToken:(NSInteger)findMyToken hasSndpKey:(NSInteger)hasSndpKey deviceAccessToken:(NSInteger)deviceAccessToken;
/// Sync time callback
/// \param stamp GMT timestamp
///
/// \param timezone Timezone
///
/// \param zoneMin Timezone minutes part
/// Data will be saved in device entity class, used to convert sessionId to timestamp
///
- (void)blePenTimeWithStamp:(NSInteger)stamp timezone:(NSInteger)timezone zoneMin:(NSInteger)zoneMin;
/// Recording pen storage
/// \param total Total storage size (bytes)
///
/// \param free Remaining storage size (bytes)
///
/// \param duration Recording pen estimated remaining recording duration (milliseconds)
///
- (void)bleStorageWithTotal:(NSInteger)total free:(NSInteger)free duration:(NSInteger)duration;
/// Reset password
/// \param password Initial password after reset
///
- (void)blePasswordResetWithPassword:(NSInteger)password;
/// Read or set backlight duration callback
/// \param duration Duration enumeration 0: 10 seconds 1: 20 seconds 2: 30 seconds 4: Always on
///
- (void)bleBacklightDuration:(NSInteger)duration;
/// Read or set backlight contrast (brightness) callback
/// \param bright Brightness level 1-6
///
- (void)bleBacklightBright:(NSInteger)bright;
/// Language
/// \param type 0 Simplified Chinese 1 Traditional Chinese 2 English
///
- (void)bleLanguage:(NSInteger)type;
/// Recording scene
/// \param scene 0 Unknown; 1 Normal; 2 Interview; 3 Classroom(Speech); 4 Music; 5 Meeting; 6 Memo
///
- (void)bleRecScene:(NSInteger)scene;
/// Recording mode
/// \param mode 1 Normal (normal, non-noise reduction); 2 NC (noise reduction)
///
- (void)bleRecMode:(NSInteger)mode;
/// VAD sensitivity
/// \param value 1：Quality; 2：Normal； 3：Aggressive
///
- (void)bleVadSensitivity:(NSInteger)value;
/// VPU sensitivity
/// \param value 1：Low; 2：Medium； 3：High
///
- (void)bleVpuGain:(NSInteger)value;
/// VPU sensitivity
/// \param value 1- 30
///
- (void)bleMicGain:(NSInteger)value;
/// SWITCH switch function
/// \param id 0：Call scene switching    1：Recording function    2：Power off function
///
- (void)bleSwitchHandler:(NSInteger)id;
/// Scheduled power off function
/// \param value 0：Off    1：Immediate power off    2：15 minutes    3：30 minutes    4：1 hour    5：5 hours
///
- (void)bleAutoPowerOff:(NSInteger)value;
/// Device stores raw wav files
/// \param value 0：Off    1：On
///
- (void)bleRawWaveEnabled:(NSInteger)value;
/// Start recording after charger is unplugged
/// \param value 0：Off    1：On
///
- (void)bleRecordingAfterDisConnetEnabled:(NSInteger)value;
/// Idle time sync
/// \param value 0：Off    1：On
///
- (void)bleSyncWhenIdleEnabled:(NSInteger)value;
/// FindMy status
/// \param value 
/// 0：Unbound status - turn off broadcast
/// 1：Unbound status - turn on broadcast
/// 2：Bound status - can be found
/// 3：Bound status - cannot be found
///
- (void)bleFindMyState:(NSInteger)value;
/// \param value 
/// 0：Off
/// 1：On
///
- (void)bleVPUCLKState:(NSInteger)value;
/// \param value 
/// 0：Off
/// 1：On
///
- (void)bleStopRecordingAfterCharging:(NSInteger)value;
/// Auto clear recording status
/// Note: Recording pen only saves status, whether to delete recording after sync completion is decided by app
/// \param open  Whether to enable 
///
- (void)bleAutoClear:(BOOL)open;
/// VAD switch status
/// \param open Whether to enable 
///
- (void)bleVad:(BOOL)open;
/// Unbind
/// \param status 0 success; 1 working 2 upgrading
///
- (void)bleDepair:(NSInteger)status;
/// WiFi open notification
/// \param status 0 normal, >1 forbidden to open 1 recording status, 2 U disk status
///
/// \param wifiName Recording pen hotspot name
///
/// \param wholeName Determine whether to append 4-digit sn suffix name
///
/// \param wifiPass Recording pen hotspot password
///
- (void)bleWiFiOpen:(NSInteger)status :(NSString * _Nonnull)wifiName :(NSString * _Nonnull)wholeName :(NSString * _Nonnull)wifiPass;
/// WiFi close notification
/// \param status 0 success 1 wifi not opened
///
- (void)bleWiFiClose:(NSInteger)status;
/// WiFi configuration result
/// \param status 0 success; 1 parameter length incorrect
///
- (void)bleSetWiFiSsidWithStatus:(NSInteger)status;
/// WiFi configuration query result
/// \param status 0 connecting
///
/// \param ssid wifi
///
- (void)bleGetWiFiSsidWithStatus:(NSInteger)status ssid:(NSString * _Nullable)ssid;
/// Recording audio abnormal reminder
/// \param status 0 normal 1 tap/audio clipping 2 audio too loud 3 audio too quiet 4 noise too loud
///
- (void)bleVoiceAbnormalWithStatus:(NSInteger)status;
/// Set or get server configuration
/// \param type 1 server url 2 server token 3 device side token
///
/// \param conent url / serToken / devToken
///
- (void)bleWebsocketProfile:(NSInteger)type :(NSString * _Nullable)conent;
/// Server test
/// \param status 0 success; 1 AP not scanned 2 AP password error 3 websocket connection failed
///
- (void)bleWebsocketTest:(NSInteger)status;
/// Start recording callback
/// \param sessionId Recording file unique id, 0 timezone timestamp, need to subtract timezone to convert to phone current timestamp
///
/// \param start Recorded duration (file offset, bytes) (returns 0 if not recording before; returns recorded duration if recording before)
///
/// \param status 0: success, >0: failure 1: storage full; 2: U disk mode; 3: hardware exception; 4: currently busy; 255: mode incorrect (recording pen not in recording mode, specific to Heili three-way switch)
///
/// \param scene Recording mode (depends on project and version number)
///
/// \param startTime Start time (depends on project and version number)
///
- (void)bleRecordStartWithSessionId:(NSInteger)sessionId start:(NSInteger)start status:(NSInteger)status scene:(NSInteger)scene startTime:(NSInteger)startTime;
/// End recording callback
/// \param sessionId Recording file unique id, 0 timezone timestamp, need to subtract timezone to convert to phone current timestamp
///
/// \param reason Reason (others undefined)
/// 1.MMI_REC_STOP_FROM_DEV    /// Device side stops recording
/// 2.MMI_REC_STOP_FROM_APP    /// APP side stops recording
/// 3.MMI_REC_STOP_BY_SPLIT        /// Auto time slice stops recording
/// 4.MMI_REC_STOP_BY_SWITCH   ///  Switch toggle stops recording
///
/// \param fileExist Whether file is saved
///
/// \param fileSize File size (if any, bytes)
///
- (void)bleRecordStopWithSessionId:(NSInteger)sessionId reason:(NSInteger)reason fileExist:(BOOL)fileExist fileSize:(NSInteger)fileSize;
/// Recording pause callback
/// \param sessionId Recording file unique id, 0 timezone timestamp, need to subtract timezone to convert to phone current timestamp
///
/// \param reason Reason (currently undefined)
///
/// \param fileExist Whether file is saved
///
/// \param fileSize File size (if any, bytes)
///
- (void)bleRecordPauseWithSessionId:(NSInteger)sessionId reason:(NSInteger)reason fileExist:(BOOL)fileExist fileSize:(NSInteger)fileSize;
/// Recording resume (starting from firmware version 7)
/// \param sessionId Recording file unique id, 0 timezone timestamp, need to subtract timezone to convert to phone current timestamp
///
/// \param start Recorded duration (file offset, bytes) (returns 0 if not recording before; returns recorded duration if recording before)
///
/// \param status 0: success, >0: failure 1: storage full; 2: U disk mode; 3: hardware exception
///
/// \param scene Recording mode (depends on project and version number)
///
/// \param startTime Start time (depends on project and version number)
///
- (void)bleRecordResumeWithSessionId:(NSInteger)sessionId start:(NSInteger)start status:(NSInteger)status scene:(NSInteger)scene startTime:(NSInteger)startTime;
/// Get recording LED effect
- (void)bleLedStateOnOff:(NSInteger)onOff;
/// Set recording LED effect
- (void)bleSetLedStateOnOff:(NSInteger)onOff;
/// Get file list callback
/// \param bleFiles File list
///
- (void)bleFileListWithBleFiles:(NSArray<BleFile *> * _Nonnull)bleFiles;
/// Sync (download) file start callback
/// \param sessionId File unique id
///
/// \param status Status, 0: success; >0: failure 1: file system currently unavailable 2: file does not exist 3: interrupted
///
- (void)bleSyncFileHeadWithSessionId:(NSInteger)sessionId status:(NSInteger)status;
/// Sync (download) file end
/// \param sessionId File unique id
///
/// \param crc File checksum, verify file integrity (don’t use after recording pen changed to egg file saving)
///
- (void)bleSyncFileTailWithSessionId:(NSInteger)sessionId crc:(NSInteger)crc;
/// Return recording mark data
/// \param sessionId Session id
///
/// \param status Status 0 normal 1 current file system unavailable
///
/// \param markList Mark data
///
- (void)bleMarkingWithSessionId:(NSInteger)sessionId status:(NSInteger)status markList:(NSArray<NSNumber *> * _Nonnull)markList;
/// Angle reporting
/// \param pitchAngle Pitch angle -180~180
///
/// \param rollbackAngle Roll angle -180~180
///
/// \param yawAngle Yaw angle -180~180
///
- (void)bleAnglesWithPitchAngle:(float)pitchAngle rollbackAngle:(float)rollbackAngle yawAngle:(float)yawAngle;
/// Data reception completed
- (void)bleDataComplete;
/// Voice data return
/// \param sessionId File id, protocol 7 support
///
/// \param start Data offset in undecoded file (bytes)
///
/// \param data Data (could be ogg data or opus pure audio, determined by firmware)
///
- (void)bleDataWithSessionId:(NSInteger)sessionId start:(NSInteger)start data:(NSData * _Nonnull)data;
/// Return decoded PCM data
/// \param sessionId File id, protocol 7 support
///
/// \param millsec Current voice millisecond value
///
/// \param pcmData Decoded data, will not callback if decoding was not requested when recording started; if recording is stereo, it will be processed to mono here; music mode is stereo 48k sample rate, will be processed to mono 48k, not available for recognition
///
/// \param isMusic Is it music mode? PCM returned in music mode is not normal PCM, it’s 6 shorts take 1, used for generating sound waves, cannot be used for recognition
///
- (void)blePcmDataWithSessionId:(NSInteger)sessionId millsec:(NSInteger)millsec pcmData:(NSData * _Nonnull)pcmData isMusic:(BOOL)isMusic;
/// Voice data decoding failed
/// \param start Data offset in undecoded file
///
- (void)bleDecodeFailWithStart:(NSInteger)start;
/// Sync file terminated
- (void)bleSyncFileStop;
/// Delete file
/// \param sessionId Protocol version 7 support
///
/// \param status Status, 0: delete successful; 1: recording in progress, deletion not allowed 2: favorited, deletion not allowed; 3: playing, deletion not allowed
///
- (void)bleDeleteFileWithSessionId:(NSInteger)sessionId status:(NSInteger)status;
/// OTA notification
/// \param uid Identifier
///
/// \param status Status 0 normal, 1. upgrade failed 2. version information mismatch 3. FLASH write failed 4. file too large 5. too many attempts 6. U disk mode; 7. recording in progress; 8. U disk insufficient remaining space; 9. working; 10. G101 glasses only allow upgrade in charging mode; 11. G101 glasses insufficient battery; 12. G101 glasses received upgrade protocol and preparing to adjust to OTA_MODE; 255: mode incorrect (recording pen not in recording mode, specific to Heili three-way switch)
///
/// \param errmsg Protocol version 4, if upgrade successful, returns upgraded version here; if failed, still returns error message.
///
- (void)bleFotaResultWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
/// OTA package request, recording pen requests to send upgrade package data
/// \param uid Identifier
///
/// \param start Start position (bytes)
///
/// \param end End position (bytes)
///
- (void)bleFotaPackReqWithUid:(NSInteger)uid start:(NSInteger)start end:(NSInteger)end;
/// OTA package reception completed
/// \param uid Identifier
///
/// \param status Status 0 normal, 1. upgrade failed 2. version information mismatch 3. FLASH write failed 4. file too large 5. too many attempts 6. U disk mode; 7. recording in progress; 8. U disk insufficient remaining space
///
/// \param errmsg Protocol version 4, if upgrade successful, returns upgraded version here; if failed, still returns error message.
///
- (void)bleFotaPackFinWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
/// OTA data send failed
- (void)bleOtaDataSendFail;
/// Bluetooth transmission rate callback
/// \param lossRate Packet loss rate
///
/// \param rate Average rate, bytes/S
///
/// \param instantRate Real-time rate
///
- (void)bleRateWithLossRate:(double)lossRate rate:(NSInteger)rate instantRate:(NSInteger)instantRate;
/// Privacy setting
/// When enabled, prohibit pen-side playback, prohibit U disk function, prohibit pen-side unbinding
- (void)blePrivacyWithPrivacy:(NSInteger)privacy;
/// Clear all files on pen side
/// 0: delete successful; 1: recording files not allowed to delete; 2: favorited files not allowed to delete; 3: playing files not allowed to delete; 4: U disk mode
- (void)bleClearAllFileWithStatus:(NSInteger)status;
/// Scheduled recording
/// \param start Start time (UTC); 0 means turn off scheduled recording
///
/// \param duration Recording duration (unit s)
///
/// \param repeatMode 0 once only valid once; 1 daily every day; 2 weekly every week
///
- (void)bleAlarmRecWithStart:(NSInteger)start duration:(NSInteger)duration repeatMode:(NSInteger)repeatMode;
/// Wake/sleep setting
/// 0: sleep; 1: wake
- (void)bleSetActiveWithStatus:(NSInteger)status;
/// BinaryFile basic information sync - FindMy Token
/// \param type File extension type (length 1 byte)
///
/// \param packageOffset File read offset value (4byte)
///
/// \param packageSize Request to get a segment of data size (2byte)
///
/// \param endStatus File end, 0 still need data; (1byte)
///
- (void)onBinaryFileReqWithType:(NSInteger)type packageOffset:(NSInteger)packageOffset packageSize:(NSInteger)packageSize endStatus:(NSInteger)endStatus;
/// Send binary data - FindMy Token setting
/// \param result Success 0 / (Failed 1 or other reasons) (1byte)
///
- (void)onBinaryFileEndWithResult:(NSInteger)result;
/// Idle sync WiFi configuration received
/// \param index WiFi number (4 bytes)
///
/// \param ssid WiFi SSID
///
/// \param password WiFi password
///
- (void)onSyncIdleWifiConfigReceivedWithIndex:(uint32_t)index ssid:(NSString * _Nonnull)ssid password:(NSString * _Nonnull)password;
/// Set idle sync WiFi configuration result
/// \param result Result code (0: success, 1: already exists, 2: device not found for deletion, 3: change not found, 4: operation code exception, 5: queue full, other: other errors)
///
- (void)onSyncIdleWifiConfigSetWithResult:(NSInteger)result;
/// Idle sync WiFi list received
/// \param list WiFi index list
///
- (void)onSyncIdleWifiListReceivedWithList:(NSArray<NSNumber *> * _Nonnull)list;
/// Idle sync WiFi deletion result
/// \param result Result code (0: success, -1: failure)
///
- (void)onSyncIdleWifiDeleteResultWithResult:(NSInteger)result;
/// Idle sync WiFi test started
/// \param index WiFi number
///
- (void)onSyncIdleWifiTestStartedWithIndex:(uint32_t)index;
/// Idle sync about to start
/// \param second Seconds about to start
///
- (void)onSyncIdleWillStartWithSeconds:(NSInteger)seconds;
/// Idle sync WiFi test result
/// \param index WiFi number
///
/// \param result Test result: 0, test success 1, wifi not found 2, Wifi password incorrect 3, Wifi connection failed 4, data transmission failed
///
/// \param rawCode Original error code
///
- (void)onSyncIdleWifiTestResultWithIndex:(uint32_t)index result:(NSInteger)result rawCode:(NSInteger)rawCode;
/// Reset FindMy status result
/// \param result Test result: 0, test success 1, wifi not found 2, Wifi password incorrect 3, Wifi connection failed 4, data transmission failed
///
- (void)onResetFindmyResultWithResult:(NSInteger)result;
- (void)onSetSoundPlusTokenResultWithLicenseKey:(NSString * _Nonnull)licenseKey;
- (void)onGetSDFlashCIDResultWithCid:(NSString * _Nonnull)cid;
@end

SWIFT_CLASS("_TtC9PenBleSDK9BleDevice")
@interface BleDevice : NSObject
/// Recorder name
@property (nonatomic, copy) NSString * _Nonnull name;
/// uuid
@property (nonatomic, copy) NSString * _Nonnull uuid;
/// Bluetooth signal strength
@property (nonatomic) float rssi;
/// Manufacturer type, MTK or Nordic
@property (nonatomic, copy) NSString * _Nonnull manufacturer;
/// Project code
@property (nonatomic) NSInteger projectCode;
/// Version type, T or V
@property (nonatomic, copy) NSString * _Nonnull versionTypeStr;
/// Version number
@property (nonatomic) NSInteger versionCode;
/// SN, device unique identifier
@property (nonatomic, copy) NSString * _Nonnull serialNumber;
/// Binding status 0 unbound, 1 bound
@property (nonatomic) NSInteger bindCode;
/// Device battery level
@property (nonatomic) NSInteger power;
/// Whether device is charging
@property (nonatomic) BOOL isCharging;
/// Total space size
@property (nonatomic) NSInteger total;
/// Device remaining space
@property (nonatomic) NSInteger free;
/// Recorder’s estimated remaining recording duration
@property (nonatomic) NSInteger duration;
/// Device current timezone
@property (nonatomic) NSInteger timezone;
/// Minutes part of timezone
@property (nonatomic) NSInteger zoneMin;
/// Number of channels
@property (nonatomic) NSInteger channels;
/// Whether WiFi is supported
@property (nonatomic) BOOL supportWiFi;
/// Whether app-side noise reduction and gain is needed
@property (nonatomic) BOOL nsAgc;
/// Is synced data complete ogg data or pure audio opus?
@property (nonatomic) BOOL isOgg;
/// Whether to delete files from recorder after syncing voice data
@property (nonatomic) NSInteger autoClear;
/// Whether to hide recording
@property (nonatomic) NSInteger hideLed;
/// Customized according to project (4099(0x00001003) indicates recorder is recording)
@property (nonatomic) NSInteger state;
/// Whether privacy setting is enabled 1 enabled; 0 disabled
@property (nonatomic) NSInteger privacy;
/// Toggle switch status, 0 no status 1 recording status 2 idle status
/// Plaud: 3 Switch on 4 Switch off
@property (nonatomic) NSInteger keyState;
/// Whether U disk is enabled, 0 not enabled 1 enabled
@property (nonatomic) NSInteger uDisk;
/// Whether findmy token exists, 0 does not exist, 1 exists
@property (nonatomic) NSInteger findmyToken;
/// Whether there is an upgrade package (obtained by accessing server via http, placed here for convenience)
@property (nonatomic) BOOL hasFota;
/// Determine whether to add the name with four digit SN suffix
@property (nonatomic, readonly, copy) NSString * _Nonnull wholeName;
/// WiFi hotspot name
@property (nonatomic, readonly, copy) NSString * _Nonnull wifiName;
- (nonnull instancetype)initWithSn:(NSString * _Nonnull)sn OBJC_DESIGNATED_INITIALIZER;
/// Version number for external display
///
/// returns:
/// Version number display string
- (NSString * _Nonnull)wholeVersion SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)toString SWIFT_WARN_UNUSED_RESULT;
/// 8：30 –> 8<em>3600+30</em>60
/// -2: 45 –> -2<em>3600-45</em>60
- (NSInteger)zoneSecond SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CBService;
@class CBCharacteristic;
@interface BleDevice (SWIFT_EXTENSION(PenBleSDK)) <CBPeripheralDelegate>
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverServices:(NSError * _Nullable)error;
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverCharacteristicsForService:(CBService * _Nonnull)service error:(NSError * _Nullable)error;
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didWriteValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
@end

/// recording file instance class
SWIFT_CLASS("_TtC9PenBleSDK7BleFile")
@interface BleFile : NSObject
/// Recording device’s unique identifier (which recording pen this recording belongs to)
@property (nonatomic, copy) NSString * _Nonnull sn;
/// Recording file id in recording pen, unique
@property (nonatomic) NSInteger sessionId;
/// file size
@property (nonatomic) NSInteger size;
/// File offset, current file download position
@property (nonatomic) NSInteger offset;
/// Current timezone
/// Pen-side file name is local time, if converting to UTC time, need to subtract timezone
@property (nonatomic) NSInteger timezone;
/// Minutes part of timezone (some countries/regions have timezone with minutes)
@property (nonatomic) NSInteger zoneMin;
/// Scene (protocol 7 support)
@property (nonatomic) NSInteger scenes;
/// Whether favorited on pen side
@property (nonatomic) NSInteger penCollect;
/// number of channels
@property (nonatomic) NSInteger channels;
/// Whether needs app-side noise reduction and gain
@property (nonatomic) BOOL nsAgc;
/// Transfer ogg file or opus?
@property (nonatomic) BOOL isOgg;
/// Is recording in music mode?
@property (nonatomic, readonly) BOOL isMusic;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initialize
/// \param sessionId file unique id
///
/// \param fileSize file size, file duration calculated through file size
///
- (nonnull instancetype)init:(NSInteger)sessionId :(NSInteger)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init:(NSString * _Nonnull)sn :(NSInteger)sessionId :(NSInteger)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init:(NSString * _Nonnull)sn :(NSInteger)sessionId :(NSInteger)size :(NSInteger)channels :(BOOL)nsAgc OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init:(NSString * _Nonnull)sn :(NSInteger)sessionId :(NSInteger)size :(NSInteger)scenes :(NSInteger)penCollect :(NSInteger)channels :(BOOL)nsAgc OBJC_DESIGNATED_INITIALIZER;
/// Get recording file duration
///
/// returns:
/// duration, unit milliseconds
- (NSInteger)duration SWIFT_WARN_UNUSED_RESULT;
/// Ogg file size convert to duration (not very precise, error within 100ms)
///
/// returns:
/// duration, unit milliseconds
/// @deprecated returns duration(), this method will be removed in future versions
- (NSInteger)oggDuration SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)toString SWIFT_WARN_UNUSED_RESULT;
/// Calculate recording file duration
/// \param fileSize file size
///
/// \param channel number of channels
///
/// \param isOgg is ogg file?
///
/// \param scenes scene, if meeting mode (4), then transfer is Wave, needs special processing
///
///
/// returns:
/// duration, milliseconds
+ (NSInteger)calculateDuration:(NSInteger)fileSize :(NSInteger)channel :(BOOL)isOgg :(NSInteger)scenes SWIFT_WARN_UNUSED_RESULT;
@end

@interface BleFile (SWIFT_EXTENSION(PenBleSDK)) <NSCopying>
/// Deep copy
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)_ SWIFT_WARN_UNUSED_RESULT;
/// Timezone convert to seconds
- (NSInteger)zoneSecond SWIFT_WARN_UNUSED_RESULT;
/// Get local timestamp through sessionId (utc 0 timezone time) and timezone
- (NSInteger)utsStamp SWIFT_WARN_UNUSED_RESULT;
@end

SWIFT_PROTOCOL("_TtP9PenBleSDK18FirmUpdateProtocol_")
@protocol FirmUpdateProtocol
/// Data push progress
/// \param progress %
///
- (void)otaPushProgressWithProgress:(NSInteger)progress;
/// Data push rate
/// \param speed instantaneous rate (kb/s)
///
/// \param avgSpeed average rate (kb/s)
///
- (void)otaPushSpeedWithSpeed:(double)speed avgSpeed:(double)avgSpeed;
/// Upgrade exception
/// \param uid identifier
///
/// \param status 1. upgrade failed 2. version information mismatch  3. FLASH write failed 4. file too large 5. too many attempts  6. USB mode; 7. recording in progress; 8. USB remaining space insufficient;  9. working in progress; 10. G101 glasses only allow upgrade in charging mode; 11. G101 glasses battery level insufficient; 12. G101 glasses received upgrade protocol and preparing to switch to OTA_MODE; 255: wrong mode (recording pen not in recording mode, specific to black switch three-position switch)
///
/// \param errmsg protocol version 4, if upgrade success, returns upgraded version; if failed, still returns error information.
///
- (void)otaPushErrWithStatus:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
/// Data push completion
- (void)otaPushFinish;
@end

/// Glasses record report data
SWIFT_CLASS("_TtC9PenBleSDK9GlassData")
@interface GlassData : NSObject
@property (nonatomic) NSInteger year;
@property (nonatomic) NSInteger month;
@property (nonatomic) NSInteger day;
@property (nonatomic) NSInteger time;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init:(uint16_t)year :(uint8_t)month :(uint8_t)day :(uint32_t)time OBJC_DESIGNATED_INITIALIZER;
@end

/// Glasses exclusive data delegate
SWIFT_PROTOCOL("_TtP9PenBleSDK13GlassProtocol_")
@protocol GlassProtocol
/// Glasses report data
/// \param delFlag Delete count statistics
///
/// \param dataArr Report data
///
- (void)glassData:(NSInteger)delFlag :(NSArray<GlassData *> * _Nonnull)dataArr;
/// Clear report data
/// \param status 0 success; 1 device in use, deletion failed
///
- (void)glassDataClear:(NSInteger)status;
@end

SWIFT_CLASS_NAMED("JXAvcDecoder")
@interface JXAvcDecoder : NSObject
/// Single channel packet size
@property (nonatomic, readonly) NSInteger packSize;
/// Two-channel packet size
@property (nonatomic, readonly) NSInteger twoChannelPackSize;
/// Four-channel packet size
@property (nonatomic, readonly) NSInteger fourChannelPackSize;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Create decoder
/// \param channels Number of channels, default 1
///
- (void)createDecoderIfNeed:(NSInteger)channels;
/// Decode single data packet
/// If decoder is abnormal or garbage collected, it will be recreated and initialized
/// \param data Data to be decoded, length is 80 * channels
///
///
/// returns:
/// Decoded data
- (NSData * _Nullable)decode:(NSData * _Nonnull)data :(NSInteger)channels SWIFT_WARN_UNUSED_RESULT;
/// Release decoder
- (void)releaseDecoder;
@end

/// CRC utility class
/// Synchronize (download) recording pen files, control the offset and concatenate properly, file won’t be wrong, but crc won’t match (pen-side file is different from what’s sent to app)
/// Sending differential upgrade package to recording pen needs to pass a crc checksum to verify file integrity
SWIFT_CLASS("_TtC9PenBleSDK11JXCrcHelper")
@interface JXCrcHelper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXCrcHelper * _Nonnull shared;)
+ (JXCrcHelper * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Get file CRC checksum
/// \param path file path
///
///
/// returns:
/// checksum, if file doesn’t exist, return -1
- (NSInteger)getCrcWithPath:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
/// Verify file CRC
/// \param crc crc value returned by pen
///
/// \param path file path
///
///
/// returns:
/// whether file is complete
- (BOOL)checkCrcWithCrc:(NSInteger)crc ofFile:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
@end

/// Audio decoding and format conversion utility class
SWIFT_CLASS("_TtC9PenBleSDK13JXFileDecoder")
@interface JXFileDecoder : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXFileDecoder * _Nonnull shared;)
+ (JXFileDecoder * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Convert PCM to WAV
/// \param pcmPath PCM file path
///
/// \param wavPath WAV file path
///
/// \param channels Number of channels, default 1
///
/// \param simpleRate Sample rate, default 16000
///
/// \param completionHandler Callback
///
- (void)pcmToWavWithPcmPath:(NSString * _Nonnull)pcmPath wavPath:(NSString * _Nonnull)wavPath channels:(uint32_t)channels simpleRate:(uint32_t)simpleRate completionHandler:(void (^ _Nonnull)(BOOL))completionHandler;
/// For audio recorded in music mode with real-time recording synchronization at the beginning, the WAV header information needs to be reset to be playable with regular players
/// \param wavPath WAV file path
///
/// \param channels Number of channels, music mode is dual channel
///
/// \param sampleRate Sample rate, music mode is 48000 (48k)
///
- (void)resetWavHead:(NSString * _Nonnull)wavPath :(uint32_t)channels :(uint32_t)sampleRate;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasAvcToWavTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertAvcToWavCancel;
/// Convert AVC undecoded data to WAV, if there are multiple files, they will be executed sequentially in queue
/// Implementation changed to C language
/// \param avcPath Raw data file path
///
/// \param wavPath WAV file path
///
/// \param channels Number of channels, default 1
///
/// \param ns_agc Whether to apply noise reduction and gain
///
/// \param clearUnfinished If there are unfinished tasks in the task queue, they will be cancelled
///
/// \param completionHandler Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)avcToWavWithAvcPath:(NSString * _Nonnull)avcPath wavPath:(NSString * _Nonnull)wavPath channels:(int32_t)channels ns_agc:(BOOL)ns_agc clearUnfinished:(BOOL)clearUnfinished completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasPcmToMp3Task SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertPcmToMp3Cancel;
/// Convert PCM recording file to MP3, if there are multiple files, they will be executed sequentially in queue
/// Don’t know why the generated MP3 cannot be played with AVAudioPlayer, but can be played with AVPlayer
/// \param pcmPath PCM file path
///
/// \param mp3Path MP3 file path to be generated
///
/// \param clearUnfinished If there are unfinished tasks in the task queue, they will be cancelled
///
/// \param quality 2 near-best quality, not too slow; 5 good quality, fast; 7 ok quality, really fast
///
/// \param channels Number of channels, default 1
///
/// \param completionHandler Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)pcmToMp3WithPcmPath:(NSString * _Nonnull)pcmPath mp3Path:(NSString * _Nonnull)mp3Path clearUnfinished:(BOOL)clearUnfinished quality:(int32_t)quality channels:(int32_t)channels completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasAvcToMp3Task SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertAvcToMp3Cancel;
/// Convert AVC raw recording file to MP3, if there are multiple files, they will be executed sequentially in queue
/// Don’t know why the generated MP3 cannot be played with AVAudioPlayer, but can be played with AVPlayer
/// \param avcPath AVC raw recording file path
///
/// \param mp3Path MP3 file path to be generated
///
/// \param clearUnfinished If there are previous unfinished tasks in the task queue, they will be cancelled
///
/// \param quality 2 near-best quality, not too slow; 5 good quality, fast; 7 ok quality, really fast
///
/// \param channels Number of channels, default 1
///
/// \param ns_agc Whether to apply noise reduction and gain
///
/// \param completionHandler Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)avcToMp3WithAvcPath:(NSString * _Nonnull)avcPath mp3Path:(NSString * _Nonnull)mp3Path clearUnfinished:(BOOL)clearUnfinished quality:(int32_t)quality channels:(int32_t)channels ns_agc:(BOOL)ns_agc completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasOggToMp3Task SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertOggToMp3Cancel;
/// Compress OGG to MP3
/// \param oggPath OGG file path
///
/// \param mp3Path MP3 file path
///
/// \param channels OGG number of channels
///
/// \param quality MP3 quality 2 near-best quality, not too slow; 5 good quality, fast; 7 ok quality, really fast default 7
///
/// \param callback Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)oggToMp3:(NSString * _Nonnull)oggPath :(NSString * _Nonnull)mp3Path :(int32_t)channels :(int32_t)quality :(void (^ _Nonnull)(BOOL, NSInteger))callback;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasOggMulToSingleTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)oggMulToSingleCancel;
/// Convert multi-channel OGG to single-channel OGG, multi-channel can be single, dual, or four channels;
/// The converted OGG is slightly smaller and can be played by Google browser
/// \param mulPath Multi-channel OGG path
///
/// \param singlePath Target single-channel path
///
/// \param channels Number of channels in multi-channel OGG
///
/// \param callback Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)oggMulToSingle:(NSString * _Nonnull)mulPath :(NSString * _Nonnull)singlePath :(int32_t)channels :(void (^ _Nonnull)(BOOL, NSInteger))callback;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
- (BOOL)hasAvcToNoiseReductionWav SWIFT_WARN_UNUSED_RESULT;
- (void)convertAvcToNoiseReductionWavCancel;
/// Convert AVC undecoded data to WAV, if there are multiple files, they will be executed sequentially in queue
/// Implementation changed to C language
/// \param avcPath Raw data file path
///
/// \param wavPath WAV file path
///
/// \param channels Number of channels, default 1
///
/// \param ns_agc Whether to apply noise reduction and gain
///
/// \param clearUnfinished If there are unfinished tasks in the task queue, they will be cancelled
///
/// \param completionHandler Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)avcToNoiseReductionWavWithAvcPath:(NSString * _Nonnull)avcPath wavPath:(NSString * _Nonnull)wavPath channels:(int32_t)channels sound_plus:(BOOL)sound_plus noiseReductionGain:(NSInteger)noiseReductionGain clearUnfinished:(BOOL)clearUnfinished completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasAvcToPcmTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertAvcToPcmCancel;
/// Convert AVC file to PCM
/// \param avcPath AVC/Opus file path
///
/// \param pcmPath PCM file path
///
/// \param clearUnfinished If there are previous unfinished tasks in the task queue, they will be cancelled
///
/// \param channels Number of channels, default 1
///
/// \param ns_agc Whether to apply noise reduction and gain
///
/// \param completionHandler Complete is true 100; failed is false -1; progress is false 0-100
///
- (void)avcToPcmWithAvcPath:(NSString * _Nonnull)avcPath pcmPath:(NSString * _Nonnull)pcmPath clearUnfinished:(BOOL)clearUnfinished channels:(int32_t)channels ns_agc:(BOOL)ns_agc completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

@interface JXFileDecoder (SWIFT_EXTENSION(PenBleSDK))
/// Whether there are unfinished tasks
- (BOOL)hasAvcToOggTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)convertAvcToOggCancel;
- (void)oggToOpus:(NSString * _Nonnull)oggPath :(NSString * _Nonnull)opusPath :(int32_t)channels :(void (^ _Nonnull)(BOOL))callback;
/// Convert AVC (Opus) to OGG, playable by NetEase Cloud Music, recognizable by SIBIT and iFlytek
/// \param avcPath AVC (Opus) file path
///
/// \param oggPath Target OGG file path
///
/// \param clearUnfinished If there are unfinished tasks in the task queue, they will be cancelled
///
/// \param iflyToolongCut iFlytek ultra-long truncation, enabled by default (maximum limit to 4 hours 59 minutes 50 seconds)
///
/// \param channels Number of channels, default 1
///
/// \param targetChannels Target number of channels (dual channel defaults to single channel conversion, can also be specified as dual channel, single channel cannot convert to dual channel)
///
/// \param ns_agc Whether to apply noise reduction and gain
///
/// \param callback Callback function, complete is true 100; failed is false -1; progress is false 0-100
///
- (void)avcToOgg:(NSString * _Nonnull)avcPath :(NSString * _Nonnull)oggPath clearUnfinished:(BOOL)clearUnfinished :(BOOL)iflyToolongCut :(int32_t)channels :(int32_t)targetChannels :(BOOL)ns_agc :(void (^ _Nonnull)(BOOL, NSInteger))callback;
@end

/// Sound wave file generation utility class
SWIFT_CLASS("_TtC9PenBleSDK15JXFileSoundWave")
@interface JXFileSoundWave : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXFileSoundWave * _Nonnull shared;)
+ (JXFileSoundWave * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Whether there are unfinished tasks
- (BOOL)hasAvcToSoundWaveTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)generateSoundWaveCancel;
/// Get sound wave from recording file
/// \param filePath recording file path
///
/// \param channels number of channels
///
/// \param isOgg is ogg or opus/avc?
///
/// \param isMusic is it music mode
///
/// \param callback callback
///
- (void)createSoundWave:(NSString * _Nonnull)filePath :(NSInteger)channels :(BOOL)isOgg :(BOOL)isMusic :(void (^ _Nonnull)(BOOL, NSInteger))callback;
/// Generate sound wave from recording file
/// \param avcPath undecoded file path
///
/// \param channels number of channels, default is 1
///
/// \param completionHandler callback result and progress
///
- (void)avcToSoundWaveWithAvcPath:(NSString * _Nonnull)avcPath channels:(NSInteger)channels completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

/// FOTA upgrade utility class
SWIFT_CLASS("_TtC9PenBleSDK13JXFirmUpdater")
@interface JXFirmUpdater : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXFirmUpdater * _Nonnull shared;)
+ (JXFirmUpdater * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// file path
@property (nonatomic, readonly, copy) NSString * _Nonnull filePath;
/// file size
@property (nonatomic, readonly) NSInteger fileSize;
/// Checksum
@property (nonatomic, readonly) NSInteger crc;
/// Used to distinguish commands, if 0, will be set to crc during initFile; if upgrade failed, can refresh uid through refreshUid method to distinguish from last upgrade
@property (nonatomic, readonly) NSInteger uid;
/// Write offset
@property (nonatomic, readonly) NSInteger offset;
@property (nonatomic, weak) id <FirmUpdateProtocol> _Nullable delegate;
/// Whether to callback transfer rate
@property (nonatomic) BOOL requireSpeed;
/// Extra delay for data packages (unit: milliseconds, delay from speed test + this value = actual delay)
@property (nonatomic) NSInteger plusDelay;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initialize file to send
/// \param path FOTA upgrade package path
///
- (BOOL)initFileWithPath:(NSString * _Nonnull)path SWIFT_METHOD_FAMILY(none) SWIFT_WARN_UNUSED_RESULT;
/// Start auto upgrade
/// This method is called after initFile, after calling, user will no longer receive the 3 OTA callback methods in BleAgent.delegate
/// Corresponding callbacks will be processed in JXFirmUpdater
/// \param toVersion Target version number, e.g.: V0016
///
- (void)autoUpdateToVersion:(NSString * _Nonnull)toVersion :(NSInteger)thirdVersion;
/// UID increments by 1, used for re-upgrade after upgrade failed
- (void)refreshUid;
/// Start writing file, called during callback
/// \param start start (offset) in onStickFotaPackReqBack callback request
///
/// \param end end (offset) in onStickFotaPackReqBack callback request
///
- (void)startWriteWithStart:(NSInteger)start end:(NSInteger)end;
/// End transfer, called when user exits upgrade interface during file transfer
- (void)stopWrite;
/// Whether currently writing file
- (BOOL)isWriting SWIFT_WARN_UNUSED_RESULT;
@end

SWIFT_PROTOCOL("_TtP9PenBleSDK11OtaProtocol_")
@protocol OtaProtocol
/// OTA notification
/// \param uid Identifier
///
/// \param status Status 0 normal, 1. upgrade failed 2. version information mismatch 3. FLASH write failed 4. file too large 5. too many attempts 6. U disk mode; 7. recording in progress; 8. U disk insufficient remaining space; 9. working; 10. G101 glasses only allow upgrade in charging mode; 11. G101 glasses insufficient battery; 12. G101 glasses received upgrade protocol and preparing to adjust to OTA_MODE; 255: mode incorrect (recording pen not in recording mode, specific to Heili three-way switch)
///
/// \param errmsg Protocol version 4, if upgrade successful, returns upgraded version here; if failed, still returns error message.
///
- (void)bleFotaResultWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
/// OTA package request, recording pen requests sending upgrade package data
/// \param uid Identifier
///
/// \param start Start position (bytes)
///
/// \param end End position (bytes)
///
- (void)bleFotaPackReqWithUid:(NSInteger)uid start:(NSInteger)start end:(NSInteger)end;
/// OTA package reception completed
/// \param uid Identifier
///
/// \param status Status 0 normal, 1. upgrade failed 2. version information mismatch 3. FLASH write failed 4. file too large 5. too many attempts 6. U disk mode; 7. recording in progress; 8. U disk insufficient remaining space; 9. working; 10. G101 glasses only allow upgrade in charging mode; 11. G101 glasses insufficient battery; 12. G101 glasses received upgrade protocol and preparing to adjust to OTA_MODE; 255: mode incorrect (recording pen not in recording mode, specific to Heili three-way switch)
///
/// \param errmsg Protocol version 4, if upgrade successful, returns upgraded version here; if failed, still returns error message.
///
- (void)bleFotaPackFinWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
@end

@interface JXFirmUpdater (SWIFT_EXTENSION(PenBleSDK)) <OtaProtocol>
- (void)bleFotaResultWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
- (void)bleFotaPackReqWithUid:(NSInteger)uid start:(NSInteger)start end:(NSInteger)end;
- (void)bleFotaPackFinWithUid:(NSInteger)uid status:(NSInteger)status errmsg:(NSString * _Nullable)errmsg;
@end

/// For streaming decoding of Opus and OGG data, OGG can only be from recording pen synchronization, other external protocols are not supported
SWIFT_CLASS("_TtC9PenBleSDK12JXPcmProcess")
@interface JXPcmProcess : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Singleton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXPcmProcess * _Nonnull shared;)
+ (JXPcmProcess * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Protocol
@property (nonatomic, weak) id <JXPcmProcessDelegate> _Nullable delegate;
/// Callback thread, default main thread
@property (nonatomic, strong) dispatch_queue_t _Nonnull callbackQueue;
/// Reset, must be reset before starting to receive data
/// \param sessionId Recording ID (@see BleFile)
///
/// \param channel Number of channels (@see BleDevice)
///
/// \param isOgg Whether it’s OGG or Opus pure audio undecoded data (@see BleDevice)
///
/// \param nsAgc Whether noise reduction and gain are needed (@see BleDevice)
///
- (void)resetWith:(NSInteger)sessionId :(NSInteger)channel :(BOOL)isOgg :(BOOL)nsAgc;
- (void)receiveData:(NSInteger)sessionId :(NSInteger)start :(NSData * _Nonnull)data;
@end

@interface JXPcmProcess (SWIFT_EXTENSION(PenBleSDK)) <JXPcmProcessDelegate>
- (void)onPcmData:(NSInteger)sessionId :(NSInteger)millSec :(NSData * _Nonnull)pcmData;
- (void)onDecodeErr:(NSInteger)millSec;
@end

/// Complete recording file volume helper utility class
SWIFT_CLASS("_TtC9PenBleSDK15JXRecordVolumer")
@interface JXRecordVolumer : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXRecordVolumer * _Nonnull shared;)
+ (JXRecordVolumer * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// How long to return a peak value? Unit is milliseconds, an 80B avc packet is 20 milliseconds, 640B pcm packet is 20 milliseconds
/// No longer supported, fixed to 1 second
@property (nonatomic) NSInteger waveInterval;
/// Volume array, inner array contains two values, first is time (seconds), second is volume (decibels)
/// Example: [[1, 54], [2, 76], [3, 46]]
/// Starting from the first second
@property (nonatomic, copy) NSArray<NSArray<NSNumber *> *> * _Nonnull volumeArr;
/// Current second reached
@property (nonatomic, readonly) NSInteger curSec;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Get average volume of a packet
/// If you want to customize, you can use this method, otherwise it’s not needed
/// \param pcmData decoded pcm data packet, mono is 640 bytes, stereo is 1280 bytes
///
- (NSInteger)averageVolume:(NSData * _Nonnull)pcmData SWIFT_WARN_UNUSED_RESULT;
/// Append a decoded data packet
/// \param start offset
///
/// \param pcmData decoded pcm data packet, mono is 640 bytes, stereo is 1280 bytes
///
/// \param channels channels
///
- (void)appendWithStart:(NSInteger)start pcmData:(NSData * _Nonnull)pcmData;
/// Reset volume queue (before starting new recording)
- (void)reset;
@end

@protocol VolumeProtocol;
/// Real-time recording volume helper utility class
SWIFT_CLASS("_TtC9PenBleSDK18JXRecordingVolumer")
@interface JXRecordingVolumer : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXRecordingVolumer * _Nonnull shared;)
+ (JXRecordingVolumer * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, weak) id <VolumeProtocol> _Nullable delegate;
/// How long to return a peak value? Unit is milliseconds, an 80B avc packet is 20 milliseconds, 640B pcm packet is 20 milliseconds
@property (nonatomic) NSInteger waveInterval;
/// Volume array, inner array contains two values, first is time (seconds), second is volume (decibels)
/// Example: [[1, 54], [2, 76], [3, 46]]
/// Starting from the first second
@property (nonatomic, readonly, copy) NSArray<NSArray<NSNumber *> *> * _Nonnull volumeArr;
/// Current second reached
@property (nonatomic, readonly) NSInteger curSec;
/// Current millisecond value
@property (nonatomic, readonly) NSInteger curMillisec;
/// Current size (offset + data size)
@property (nonatomic, readonly) NSInteger curFileSize;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Get average volume of a packet
/// If you want to customize, you can use this method, otherwise it’s not needed
/// \param pcmData decoded pcm data packet, 640, if it’s 1280 stereo, will be converted to mono 640
///
- (CGFloat)averageVolume:(NSData * _Nonnull)pcmData SWIFT_WARN_UNUSED_RESULT;
/// Append a decoded data packet
/// \param start original data offset
///
/// \param pcmData decoded data (note: stereo will become mono)
///
/// \param channels number of channels
///
- (void)appendWithStart:(NSInteger)start pcmData:(NSData * _Nonnull)pcmData channels:(NSInteger)channels;
/// Append a decoded data packet (mono)
/// \param millSec millisecond value
///
/// \param pcmData decoded data
///
- (void)append:(NSInteger)millSec :(NSData * _Nonnull)pcmData;
/// Initialize historical data
- (void)setOldVolumeMetersWithMeters:(NSArray<NSArray<NSNumber *> *> * _Nonnull)meters;
/// Reset volume queue (before starting new recording)
- (void)reset;
@end

SWIFT_CLASS("_TtC9PenBleSDK17JXWave2PcmProcess")
@interface JXWave2PcmProcess : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Singleton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXWave2PcmProcess * _Nonnull shared;)
+ (JXWave2PcmProcess * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Protocol
@property (nonatomic, weak) id <JXPcmProcessDelegate> _Nullable delegate;
/// Callback thread, default main thread
@property (nonatomic, strong) dispatch_queue_t _Nonnull callbackQueue;
/// Reset, must be reset before starting to receive data
/// \param sessionId Recording ID
///
- (void)resetWith:(NSInteger)sessionId;
/// Receive Wave data
/// \param sessionId Recording ID
///
/// \param start Offset
///
/// \param data Wave data
///
- (void)receiveData:(NSInteger)sessionId :(NSInteger)start :(NSData * _Nonnull)data;
@end

/// This is for testing
SWIFT_CLASS("_TtC9PenBleSDK12JXWaveHelper")
@interface JXWaveHelper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) JXWaveHelper * _Nonnull shared;)
+ (JXWaveHelper * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tmpPcmPath;)
+ (NSString * _Nonnull)tmpPcmPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tmpWavPath;)
+ (NSString * _Nonnull)tmpWavPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull leftPath;)
+ (NSString * _Nonnull)leftPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull rightPath;)
+ (NSString * _Nonnull)rightPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull leftWavPath;)
+ (NSString * _Nonnull)leftWavPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull rightWavPath;)
+ (NSString * _Nonnull)rightWavPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull leftLycPath;)
+ (NSString * _Nonnull)leftLycPath SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull rightLycPath;)
+ (NSString * _Nonnull)rightLycPath SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Add file header to pcm file to convert to wave file
/// \param pcmFilePath pcm file path
///
/// \param wavFilePath wave file path
///
/// \param channels number of channels, default 1
///
///
/// returns:
/// whether successful
- (BOOL)pcmFileToWaveWithPcmFilePath:(NSString * _Nonnull)pcmFilePath wavFilePath:(NSString * _Nonnull)wavFilePath channels:(uint32_t)channels simpleRate:(uint32_t)simpleRate SWIFT_WARN_UNUSED_RESULT;
/// Separate left and right channels
- (void)divideLeftAndRight:(NSString * _Nonnull)wavePath :(NSString * _Nonnull)leftPath :(NSString * _Nonnull)rightPath handler:(void (^ _Nonnull)(BOOL))handler;
@end

/// Sound wave file generation utility class
SWIFT_CLASS("_TtC9PenBleSDK15PDFileSoundWave")
@interface PDFileSoundWave : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PDFileSoundWave * _Nonnull shared;)
+ (PDFileSoundWave * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Whether there are unfinished tasks
- (BOOL)hasAvcToSoundWaveTask SWIFT_WARN_UNUSED_RESULT;
/// Cancel current task (if any), clear task queue
- (void)generateSoundWaveCancel;
/// Get sound wave from recording file
/// \param filePath Recording file path
///
/// \param channels Number of channels
///
/// \param isOgg Is it OGG or Opus/AVC?
///
/// \param isMusic Is it music mode?
///
/// \param callback Callback
///
- (void)createSoundWave:(NSString * _Nonnull)filePath :(NSInteger)channels :(BOOL)isOgg :(BOOL)isMusic :(void (^ _Nonnull)(BOOL, NSInteger))callback;
/// Generate sound wave from recording file
/// \param avcPath Undecoded file path
///
/// \param channels Number of channels, default is 1
///
/// \param completionHandler Callback result and progress
///
- (void)avcToSoundWaveWithAvcPath:(NSString * _Nonnull)avcPath channels:(NSInteger)channels completionHandler:(void (^ _Nonnull)(BOOL, NSInteger))completionHandler;
@end

/// Complete recording file volume helper utility class
SWIFT_CLASS("_TtC9PenBleSDK15PDRecordVolumer")
@interface PDRecordVolumer : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PDRecordVolumer * _Nonnull shared;)
+ (PDRecordVolumer * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// How long to return a peak value? Unit is milliseconds, an 80B avc packet is 20 milliseconds, 640B pcm packet is 20 milliseconds
/// No longer supported, fixed to 1 second
@property (nonatomic) NSInteger waveInterval;
/// Volume array, inner array contains two values, first is time (seconds), second is volume (decibels)
/// Example: [[1, 54], [2, 76], [3, 46]]
/// Starting from the first second
@property (nonatomic, copy) NSArray<NSArray<NSNumber *> *> * _Nonnull volumeArr;
/// Current second reached
@property (nonatomic, readonly) NSInteger curSec;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Get average volume of a packet
/// If you want to customize, you can use this method, otherwise it’s not needed
/// \param pcmData decoded pcm data packet, mono is 640 bytes, stereo is 1280 bytes
///
- (NSInteger)averageVolume:(NSData * _Nonnull)pcmData SWIFT_WARN_UNUSED_RESULT;
/// Append a decoded data packet
/// \param start offset
///
/// \param pcmData decoded pcm data packet, mono is 640 bytes, stereo is 1280 bytes
///
/// \param channels channels
///
- (void)appendWithStart:(NSInteger)start pcmData:(NSData * _Nonnull)pcmData;
/// Reset volume queue (before starting new recording)
- (void)reset;
@end

@protocol PDVolumeProtocol;
/// Real-time recording volume helper utility class
SWIFT_CLASS("_TtC9PenBleSDK18PDRecordingVolumer")
@interface PDRecordingVolumer : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PDRecordingVolumer * _Nonnull shared;)
+ (PDRecordingVolumer * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, weak) id <PDVolumeProtocol> _Nullable delegate;
/// How long to return a peak value? Unit is milliseconds, an 80B avc packet is 20 milliseconds, 640B pcm packet is 20 milliseconds
@property (nonatomic) NSInteger waveInterval;
/// Volume array, inner array contains two values, first is time (seconds), second is volume (decibels)
/// Example: [[1, 54], [2, 76], [3, 46]]
/// Starting from the first second
@property (nonatomic, readonly, copy) NSArray<NSArray<NSNumber *> *> * _Nonnull volumeArr;
/// Current second reached
@property (nonatomic, readonly) NSInteger curSec;
/// Current millisecond value
@property (nonatomic, readonly) NSInteger curMillisec;
/// Current size (offset + data size)
@property (nonatomic, readonly) NSInteger curFileSize;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Get average volume of a packet
/// If you want to customize, you can use this method, otherwise it’s not needed
/// \param pcmData decoded pcm data packet, 640, if it’s 1280 stereo, will be converted to mono 640
///
- (CGFloat)averageVolume:(NSData * _Nonnull)pcmData SWIFT_WARN_UNUSED_RESULT;
/// Append a decoded data packet
/// \param start original data offset
///
/// \param pcmData decoded data (note: stereo will become mono)
///
/// \param channels number of channels
///
- (void)appendWithStart:(NSInteger)start pcmData:(NSData * _Nonnull)pcmData channels:(NSInteger)channels;
/// Append a decoded data packet (mono)
/// \param millSec millisecond value
///
/// \param pcmData decoded data
///
- (void)append:(NSInteger)millSec :(NSData * _Nonnull)pcmData;
/// Initialize historical data
- (void)setOldVolumeMetersWithMeters:(NSArray<NSArray<NSNumber *> *> * _Nonnull)meters;
/// Reset volume queue (before starting new recording)
- (void)reset;
@end

SWIFT_PROTOCOL("_TtP9PenBleSDK16PDVolumeProtocol_")
@protocol PDVolumeProtocol
/// Duration change
- (void)onDurationWithMillisec:(NSInteger)millisec;
/// Callback volume level
/// \param sec Which second? Starting from 1, each integer second will have an average volume of the previous second
///
/// \param volume Unit decibels
///
- (void)onVolumeWithSec:(NSInteger)sec volume:(NSInteger)volume;
/// Callback volume level
/// \param mescSecond Every twenty milliseconds as an interval, starting from 0, each twenty milliseconds corresponds to a decibel value
///
/// \param volume Unit decibels
///
- (void)onVolumePerTwentyMsecWithMescSecond:(NSInteger)mescSecond volume:(NSInteger)volume;
@end

/// Recording pen firmware upgrade information
SWIFT_CLASS("_TtC9PenBleSDK10UpdateInfo")
@interface UpdateInfo : NSObject
/// Which recording pen?
@property (nonatomic, copy) NSString * _Nonnull sn;
/// Firmware version (e.g.: T0004)
@property (nonatomic, copy) NSString * _Nonnull swVersion;
/// Current version (e.g.: V1.0.0)
@property (nonatomic, copy) NSString * _Nonnull currentVersion;
/// Target version, empty means no upgrade version
@property (nonatomic, copy) NSString * _Nonnull version;
/// Download address
@property (nonatomic, copy) NSString * _Nonnull url;
/// Size
@property (nonatomic) NSInteger size;
/// Update information
@property (nonatomic, copy) NSString * _Nonnull modifyDesc;
/// “This upgrade will take approximately 10 minutes”
@property (nonatomic, copy) NSString * _Nonnull updateDesc;
@property (nonatomic, copy) NSString * _Nonnull updatePreTip;
@property (nonatomic, copy) NSString * _Nonnull updatingTip;
@property (nonatomic, copy) NSString * _Nonnull failureTip;
/// Initial version
@property (nonatomic, copy) NSString * _Nonnull fromVersion;
/// Target version
@property (nonatomic, copy) NSString * _Nonnull toVersion;
/// MD5 checksum integrity
@property (nonatomic, copy) NSString * _Nonnull md5;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Does current recording pen need firmware upgrade?
- (BOOL)hasNewVersion:(BleDevice * _Nonnull)device SWIFT_WARN_UNUSED_RESULT;
/// Verify MD5, path is the path of upgrade package after download
- (BOOL)checkMD5WithPath:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
/// For printing convenience
- (NSString * _Nonnull)toString SWIFT_WARN_UNUSED_RESULT;
@end

SWIFT_PROTOCOL("_TtP9PenBleSDK14VolumeProtocol_")
@protocol VolumeProtocol
/// Duration change
- (void)onDurationWithMillisec:(NSInteger)millisec;
/// Callback volume level
/// \param sec Which second? Starting from 1, each integer second will have an average volume of the previous second
///
/// \param volume Unit decibels
///
- (void)onVolumeWithSec:(NSInteger)sec volume:(NSInteger)volume;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
